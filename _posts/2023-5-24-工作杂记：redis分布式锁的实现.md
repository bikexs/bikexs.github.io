---
title: redis分布式锁的实现
author: bikexs
date: 2023-6-24 7:00:00 +0800
categories: [java, other]
tags: [工作杂记]
math: true
mermaid: true
---

### 1. 背景

最近刚碰到一个需要处理不同任务执行节点中的一个数据同步，在各个任务节点中，需要依赖一个任务节点去刷新一个全局cookie数据，这个数据刷新过程中不允许被进行二次刷新，也就是不能被多个任务节点同时执行。

实现中需要用到分布式锁进行一个同步，这里稍稍总结下（实际上项目中大佬已经写好了这个分布式锁）。

### 2. 锁的基本条件
- 互斥。只能有一个线程获得锁
- 可重入。可以多次获得锁，且不会发生死锁。
- 安全。使用完成后必须释放

分布式环境中:
- 高性能。
- 高可用。
- 锁失效机制。服务挂掉了也要保证锁能够释放
- 非阻塞特性。无法获取锁时需要直接返回失败，不能一直等待阻塞。

### 2. 基于数据库唯一索引实现

![](https://z1.ax1x.com/2023/12/11/piRTTAI.png)
通过一个唯一索引字段进行实现，可以将需要互斥执行的方法名作为唯一索引，
当一个线程能成功插入一条记录的时候，就表示正常获得锁；
线程执行完成需要释放锁的时候只需要删除这条唯一索引对应 的记录即可。

ps: 唯一索引的值不一定是方法名，可以自定义生成的方式，保证不同线程同一方法生成的key相同即可。

优点：
- 实现简单，不需要额外配置环境。

缺点：
- 增加数据库压力，性能有限。
- 线程执行过程中如果节点挂掉，会直接导致死锁。这点可以通过加上一个createTime字段，然后通过一个定时任务去清理超过最大时间的记录，进而达到删除锁。
- mysql挂掉时有风险。

### 3. 基于redis实现

这种方式主要使用redis的setNx命令（set if not exists）来进行互斥写入。
![](https://z1.ax1x.com/2023/12/11/piRT7Nt.png)

原理上也是一样，如果成功set，那么就代表获得了锁；
删除只需要删除掉对应的key就行了。key的生成规则同样不一定是方法名，可以自定义生成逻辑。

优点：
- 实现简单，性能也不错。
- 对死锁情况可以直接使用redis的过期时间进行设置，从而达到自动清理过期的key。

缺点：
- redis挂掉时有风险，一般redis集群部署，保证主从一致性。

### 4.Zookeeper实现

**原理：**

ZooKeeper是一个为分布式应用提供一致性服务的开源组件，它内部是一个分层的文件系统目录树结构，规定同一个目录下只能有一个唯一文件名。基于ZooKeeper实现分布式锁的步骤如下：

创建一个目录mylock；

线程A想获取锁就在mylock目录下创建临时顺序节点；

获取mylock目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁；

线程B获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点；

线程A处理完，删除自己的节点，线程B监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。


**实现流程：**

建议直接使用Curator，它是一个ZooKeeper客户端，Curator提供的InterProcessMutex是分布式锁的实现，acquire方法用于获取锁，release方法用于释放锁。


### 其他：
项目中一般不会自己从头写分布式锁，可以使用redisson库
