---
title: Mysql专题: Mysql的索引机制
author: bikexs
date: 2024-3-1 7:00:00 +0800
categories: [Java]
tags: [Mysql]
math: true
mermaid: true
---

### 一、问题背景

索引是怎么工作的，应该怎么确保自己是否正确的使用了索引。



### 二、InnoDb索引的工作原理

#### 2.1、索引的基本概念和数据结构

##### 2.1.1、基本概念

索引本身就是相当于一个查找树，类似与数据结构中的二叉查找树、平衡二叉树等等这些搜索用的数据结构。

而对于数据库表而言，指定key等同于指定这个搜索数据结构中节点的key，通过合适的数据结构来达到一个快速搜索到目标节点的目的。

对于innodb而言，采用的数据结构是B+树数据结构，主要处于磁盘IO、查找效率方面进行考虑。

对于二叉查找树而言，本身就可能存在一个最坏情况，直接退化成链表的情况，这个缺点太明显；

对于平衡二叉树而言，本身保了一个树的高度平衡，是一个可选的数据结构。

但处于磁盘IO的考虑，需要尽可能的减少磁盘IO，所以使用B+树更为合适，相比于AVL，B+树的每个节点的大小会接近于磁盘块的大小，也就是一次IO读取一块数据，就可以读取多个键值对，相比于AVL的每个节点一个key和两个value指针，B+树在磁盘读取的时候可以用更少的读取次数。



##### 2.1.2、B+树的数据结构简述

![B+树数据结构](https://s21.ax1x.com/2024/07/29/pkLeg6x.png)

这个是《MYSQL InnoDB》里的一张图，借用一下。

最下面一层是叶子节点，在主键索引中，叶子节点是直接存放数据的，而非主键索引叶子节点是不存放数据的，而是存放逐渐索引对应叶子节点的key。叶子节点中，每个叶子节点存放一条或多条记录，并且逻辑上是有序的，节点之间通过pre指针和next指针连接，也就是说通过最开始的一个节点，是可以直接把所有数据都给遍历出来的。

叶子节点之上是索引节点，存放的索引数据，同样逻辑上是有序的，每个节点同样包括pre指针和next指针。

在B+数的插入和删除过程中，所有节点的顺序始终是保持有序的，具体怎么操作是B+树数据结构的操作，这里不展开。



结合数据库建表而言，在创建表之后，每个表会存在一个主键，主键索引会自动建立，而当往表中插入和删除数据的时候，主键索引数据同样的会进行插入和删除，这个mysql内部自动进行处理的。

#### 2.2、索引类别：主键索引

上面说到，主键索引是创建表之后mysql自动创建的一个索引。同时，这个索引也是表查询和操作的核心，非主键索引最终都是会通过主键索引查找到最终的数据，因为只有主键索引的叶子节点才存储了具体的数据。

结合两条sql来说明下主键索引是怎么工作的。

建表：

```sql
# 只创建一个主键索引
create table T1 (
	id int not null,
	name varchar(16) not null,
	desc varchar(64) not null,
	primary key (id)
) ENGINE = INNODB;
```



##### 2.2.1、查询1：`select * from T1`

这个查询中，没有任何的条件语句，也就是进行的一个全表扫描，执行过程也就是通过索引树根节点找到最左边的节点，然后通过顺序遍历所有叶子节点得出所有的数据。

实际上这会有一个小问题，因为查询并没有指定顺序，所以根据B+树的查找逻辑，最终返回的结果实际上是根据主键进行升序排序的，也就是根据B+树的key升序返回。

##### 2.2.2、查询2：`select * from T1 order by name desc`

这个查询中，没有对`name`字段添加索引，因此最终的查询则是查找出所有的数据然后进行一个排序处理。

显然这种情况下，在一张大表中，效率是非常低的。针对这个角度想，如果说我们对name这个字段也创建一个索引树，是不是就是可以直接使用这个新创建到的索引树排好序的结构直接查出来，从而避免了再进行排序这个复杂的操作。

而对于非主键添加的索引就是非主键索引，也叫做非聚集索引。

#### 2.3、索引类别：非主键索引

非主键之外创建的索引叫做非主键索引。

同样的，对于非主键索引，也是会对应的创建一个索引树，和主键索引树不同的是，非主键索引的叶子节点不会存储数据，而是存储的主键索引的key，通过这个key在主键索引树中查找对应的数据记录。因此非聚集索引也称之为辅助索引，用于辅助查询。

#### 2.4、针对多列字段的联合索引

在创建多列索引的时候，key就不会是单个值，也是一个列表值，比如

`alter table T1 add unique uk_name_desc(name, desc)`， 

最终的节点key的值就是 (name1, desc1)，其中name1，desc1分别对应该字段值，即使是字符串类型，节点的key也是存储的值（实际上想想如果存储hashcode，要处理hash冲突、比较、覆盖索引等行为都不方便）。

而在索引查找的时候，则是会根据字段顺序从左到右进行排序，也就是类似下面的一个组织结构。

```
      [ (2, 1) ]
     /         \
[ (1, 2), (1, 3) ]   [ (2, 2), (3, 1) ]
```

需要注意的是，name这一列有序，并且在name相同的时候，同属于这个name的几个叶子节点都是有序的，但是如果直接使用desc作为查询条件，索引是不会生效的，因为desc这一些并不是有序的。

#### 2.5、查询优化之覆盖索引

在联合索引中，会包括多个字段列，如果直接在多个字段列中直接查找到的所需要的字段值，那么就没必要先查出来key然后再去主键索引中查询对应的记录，也就是没必要进行一个回表的操作。而直接通过非聚集索引就能查出来需要的数据，避免了回表操作，这个就是覆盖索引。

在一些代码规范中，都会明确要求指定查询的字段列返回值，有时候这个也能够帮助排查出慢查询问题。

#### 2.6、Mysql内部优化之MRR（multi-range read)

这个翻译过来应该是叫做多范围读取，我的理解就是一次读取多个快，减少磁盘IO。在数据物理存储上也是顺序的时候，顺序读取一次行读取多个快的效率会比离散读快很多。当然，这部操作时mysql内部帮我们处理的，默认功能是开启的，可以通过配置来决定是否开启这个功能配置。

#### 2.7、sql优化之索引下推ICP（index condition pushdown)

索引下推（Index Condition Pushdown, ICP）是 MySQL 5.6 引入的一项优化技术，旨在提高索引扫描效率。在没有 ICP 的情况下，所有的行都需要回表检查是否符合查询条件；而有了 ICP 后，部分查询条件可以在索引扫描过程中进行过滤，减少了回表次数，提升了查询性能。例如，在 `SELECT * FROM users WHERE age > 30 AND status = 'active'` 中，如果 age 和 status 都包含在索引中，ICP 会在扫描索引时直接过滤不满足条件的行。

#### 2.8、mysql内部优化之自适应哈希索引

当某些页面上的数据被频繁访问时，InnoDB 会自动将这些页面转换为哈希索引，以提高查询速度。自适应哈希索引无需人工干预，完全由 InnoDB 自动管理。它的工作原理是在内存中维护一个哈希表，加速热数据的访问，提高查询效率。









